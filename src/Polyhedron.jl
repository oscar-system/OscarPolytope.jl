@doc Markdown.doc"""
    Polyhedron(A, b)

The (metric) polyhedron defined by

$$P(A,b) = \{ x |  Ax ≤ b \}.$$

see Def. 3.35 and Section 4.1.
""" struct Polyhedron #a real polymake polyhedron
    pm_polytope::Polymake.BigObjectAllocated
    boundedness::Symbol # Values: :unknown, :bounded, :unbounded
end
function Polyhedron(pm_polytope::Polymake.BigObjectAllocated)
    Polyhedron(pm_polytope, :unknown)
end
function Polyhedron(A::AbstractMatrix, b)
    Polyhedron(Polymake.polytope.Polytope{Rational}(
        INEQUALITIES = matrix_for_polymake([b -A]),
    ))
end

"""
    pm_polytope(P::Polyhedron)

Get the underlying polymake `Polytope`.
"""
pm_polytope(P::Polyhedron) = P.pm_polytope

function ==(P0::Polyhedron, P1::Polyhedron)
    return pm_polytope(P0) == pm_polytope(P1)
end

###############################################################################
###############################################################################
### Display
###############################################################################
###############################################################################
function Base.show(io::IO, P::Polyhedron)
    display(pm_polytope(P))
    # if property_is_computed(P, :VERTICES)
    #    println(io, "Polyhedron given as the convex hull of the columns of V, where\nV = ")
    #    Base.print_array(io, vertices(P))
    #    R = rays(P)
    #    if size(R, 2) > 0
    #       println(io, "\n\nwith rays given as the columns of R, where\nR =")
    #       Base.print_array(io, R)
    #    end
    #    L = lineality_space(P)
    #    if size(L,2) > 0
    #       println(io, "\n\nwith lineality space minimally generated by the columns of L, where\nL =")
    #       Base.print_array(io, L)
    #    end
    #    return
    # elseif property_is_computed(P, :INEQUALITIES)
    #    ineq = pm_polytope(P).INEQUALITIES
    #    println(io, "Polyhedron given by { x | A x ≤ b } where ")
    #    println(io, "\nA = ")
    #    Base.print_array(io, -dehomogenize(ineq))
    #    println(io, "\n\nb = ")
    #    Base.print_array(io, ineq[:,1])
    # else
    #    println(io, "A Polyhedron with neither vertex nor face representation computed.")
    # end
end

function property_is_computed(P::Polyhedron, S::Symbol)
   return property_is_computed(pm_polymake(P), S)
end

###############################################################################
###############################################################################
### Access properties
###############################################################################
###############################################################################
"""
   dim(H::Polyhedron)

Returns the dimension of a polyhedron.
"""
dim(H::Polyhedron) = Polymake.polytope.dim(pm_polytope(H))

"""
   ambient_dim(H::Polyhedron)

Returns the ambient dimension of a polyhedron.
"""
ambient_dim(H::Polyhedron) = Polymake.polytope.ambient_dim(pm_polytope(H))

"""
   vertices(H::Polyhedron)

Returns the vertices of a polyhedron.
"""
function vertices(P::Polyhedron)
    decompose_vdata(pm_polytope(P).VERTICES).vertices
end

"""
   rays(P::Polyhedron)

Returns minimal set of generators of the cone of unbounded directions of a polyhedron.
"""
rays(P::Polyhedron) = decompose_vdata(pm_polytope(P).VERTICES).rays

"""
   facets(H::Polyhedron)

Returns the facets of a polyhedron.
"""
facets(H::Polyhedron) = decompose_hdata(pm_polytope(H).FACETS)

@doc Markdown.doc"""
   cube(d [, u, l])

Construct the $[-1,1]$-cube in dimension $d$. If $u$ and $l$ are given, the $[l,u]$-cube in dimension $d$ is returned.
"""
cube(d) = Polyhedron(Polymake.polytope.cube(d))
cube(d, u, l) = Polyhedron(Polymake.polytope.cube(d, u, l))

"""
   lineality_space(H::Polyhedron)

Returns a basis of the lineality space of a polyhedron.
"""
lineality_space(H::Polyhedron) = dehomogenize(pm_polytope(H).LINEALITY_SPACE)

###############################################################################
###############################################################################
### Standard constructions
###############################################################################
###############################################################################

@doc Markdown.doc"""
    convex_hull(V [, R [, L]])

The polytope given as the convex hull of the columns of V. Optionally, rays (R)
and generators of the lineality space (L) can be given as well.

see Def. 2.11 and Def. 3.1.
""" function convex_hull(V::AbstractVecOrMat)
    pm_polytope = Polymake.polytope.Polytope{Rational}(POINTS = homogenize(V, 1))
    return Polyhedron(pm_polytope)
end
function convex_hull(V::AbstractVecOrMat, R::AbstractVecOrMat)
    points = [homogenize(V, 1); homogenize(R, 0)]
    pm_polytope = Polymake.polytope.Polytope{Rational}(POINTS = points)
    return Polyhedron(pm_polytope)
end
function convex_hull(V::AbstractVecOrMat, R::AbstractVecOrMat, L::AbstractVecOrMat)
    points = [homogenize(V, 1); homogenize(R, 0)]
    lineality = homogenize(L, 0)
    pm_polytope =
        Polymake.polytope.Polytope{Rational}(POINTS = points, INPUT_LINEALITY = lineality)
    return Polyhedron(pm_polytope)
end

# @doc Markdown.doc"""
#     DualPolyhedron(A, c)
#
# The (metric) polyhedron defined by
#
# $$P^*(A,c) = \{ y | yA = c, y ≥ 0 \}.$$
#
# see Theorem 4.11.
# """
# function DualPolyhedron(A, c)
#     #here BigInt, Integer, (fmpz, fmpq) -> Rational
#     #     nf_elem quad real field: -> QuadraticExtension
#     #     float -> Float
#     #     mpfr, BigFloat -> AccurateFloat
#     #
#     m, n = size(A)
#     cA = matrix_for_polymake([c -LinearAlgebra.transpose(A)])
#     nonnegative = [zeros(BigInt, m, 1)  LinearAlgebra.I]
#     P_star = Polymake.polymake.Polytope{Rational}(EQUATIONS=cA, INEQUALITIES=nonnegative)
#     H = HomogeneousPolyhedron(P_star)
#     return Polyhedron(H)
# end
